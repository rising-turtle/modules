#include "AreaStore.h"
#include <windows.h>
#include <tchar.h>
#include <direct.h>


CAreaStore::CAreaStore(){
	m_RootPath = "d:\\areastore";
}

CAreaStore::~CAreaStore(){

}

bool CAreaStore::LoadConfig(std::string rootpath){
	m_RootPath = rootpath;
	return true;
}

bool CAreaStore::File2AreaMap(pcl::PointCloud<pcl :: PointXYZRGB>::Ptr& pc, unsigned long id){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(id, AreaFileType::Map, "rb");
	AreaStoreHdr hdr;
	if(file && fread((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(hdr.id == id);
		for(unsigned int i=0; i<hdr.size; i++){
			BGRXYZPt pt;
			pcl::PointXYZRGB p;
			fread((void*)&pt, 1, sizeof(pt), file);
			p.x = pt.x; p.y = pt.y; p.z = pt.z;
			p.r = pt.r; p.g = pt.g; p.b = pt.b; 
			pc->points.push_back(p);
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
}

bool CAreaStore::AreaMap2File(pcl::PointCloud<pcl :: PointXYZRGB>::Ptr& pc, AreaStoreHdr& hdr){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(hdr.id, AreaFileType::Map, "wb");
	// TODO: crc checksum calculation!!!
	// TODO: take consideration of little-eigen big-eigen problem!!!
	if(file && fwrite((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(pc->points.size() == hdr.size);
		for(unsigned int i=0; i<hdr.size; i++){
			BGRXYZPt pt(pc->points[i]);
			fwrite((void*)&pt, 1, sizeof(pt), file);
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
}

bool CAreaStore::Area3DDesc2File(Area3DDescMap& map, Area3DDescStoreHdr& hdr){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(hdr.id, AreaFileType::Desc, "wb");

	// TODO: crc checksum calculation!!!
	// TODO: take consideration of little-eigen big-eigen problem!!!
	if(file && fwrite((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(map.size() == hdr.size);
		for(Area3DDescMap::iterator it=map.begin(); it != map.end(); it++){
			Node3DDesc node3DDesc={0};
			node3DDesc.id = it->first;
			node3DDesc.n = it->second.size();
			fwrite((void*)&node3DDesc, 1, sizeof(node3DDesc), file);
			for(std::vector<Feature3DDesc>::iterator iter=it->second.begin(); iter != it->second.end(); iter++)
				fwrite((void*)&(*iter), 1, sizeof(Feature3DDesc), file);
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
};

bool CAreaStore::File2Area3DDesc(Area3DDescMap& map, unsigned long id){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(id, AreaFileType::Desc, "rb");
	Area3DDescStoreHdr hdr;
	if(file && fread((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(hdr.id == id);
		for(unsigned int n=0; n<hdr.size; n++){
			Node3DDesc node3DDesc={0};
			fread((void*)&node3DDesc, 1, sizeof(node3DDesc), file);
			std::vector<Feature3DDesc> descList; 
			for(unsigned int i=0; i<node3DDesc.n; i++){
				Feature3DDesc desc={0};
				fread((void*)&desc, 1, sizeof(desc), file);
				descList.push_back(desc);
			}
			map[node3DDesc.id] = descList;
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
};

bool CAreaStore::AreaPath2File(AreaPathList& path, AreaPathStoreHdr& hdr){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(hdr.id, AreaFileType::Path, "wb");

	// TODO: crc checksum calculation!!!
	// TODO: take consideration of little-eigen big-eigen problem!!!
	if(file && fwrite((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(path.size() == hdr.size);
		for(int i=0; i<path.size(); i++){
			NodePose pose = path[i];
			fwrite((void*)&pose, 1, sizeof(pose), file);
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
};

bool CAreaStore::File2AreaPath(AreaPathList& path, unsigned long id){
	// the file name is generated by id and root_path
	FILE* file = OpenAreaFile(id, AreaFileType::Path, "rb");

	AreaPathStoreHdr hdr;
	if(file && fread((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr)){
		assert(hdr.id == id);
		for(unsigned int n=0; n<hdr.size; n++){
			NodePose pose={0};
			fread((void*)&pose, 1, sizeof(pose), file);
			path.push_back(pose);
		}
	}
	else
		return false;
	if(file)
		fclose(file);
	return true;
};

// ASCII version
bool CAreaStore::GetStoreHdrList(AreaStoreHdrList& hdrs){
    WIN32_FIND_DATAA   fdata;
    char path[MAX_PATH] = {0};
	char pathfull[MAX_PATH] = {0};
    strcpy(path, m_RootPath.c_str());
    if(path[strlen(path)-1] != '\\')
	{
		strcat(path, "\\");
	}
	strcpy(pathfull, path);
	strcat(path, "*.amf");

    HANDLE ffhandle = FindFirstFileA(path, &fdata);
    if(ffhandle != INVALID_HANDLE_VALUE){
        do
		{
            if((strcmp(fdata.cFileName,".") != 0) && (strcmp(fdata.cFileName,"..") != 0)){
                if(fdata.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY){
                    char filename[MAX_PATH] = {0};
					strcpy(filename, pathfull);
					strcat_s(filename,fdata.cFileName);
					// read the header data from areamap file
					FILE* file = fopen(filename, "r");
					AreaStoreHdr hdr;
					if(file && fread((void*)&hdr, 1, sizeof(hdr), file) == sizeof(hdr))
						hdrs.push_back(hdr);
					fclose(file);
                }
            }
        } 
        while(FindNextFileA(ffhandle,&fdata) != 0);
    }else
		return false;

    FindClose(ffhandle);

	return true;
}
FILE*  CAreaStore::OpenAreaFile(unsigned long id, AreaFileType type, const char* mode){
	std::string filename;
	std::stringstream stream;
	stream<<m_RootPath<<"\\"<<id;
	switch(type){
		case AreaFileType::Map: 
			stream<<".amf";
			break;
		case AreaFileType::Desc:
			stream<<".adf";
			break;
		case AreaFileType::Path:
			stream<<".apf";
			break;
		default:
			return NULL;
	}
	stream>>filename;
	if(strcmp(mode,"wb") ==0){
		// Create the path if NOT exist!!!
		std::string dirname;
		int pos = m_RootPath.find_first_of("\\");
		pos = m_RootPath.find_first_of("\\", ++pos);
		while(pos != -1){
			dirname = m_RootPath.substr(0, pos);
			mkdir(dirname.c_str());
			pos = m_RootPath.find_first_of("\\", ++pos);
		}
		mkdir(m_RootPath.c_str());
	}

	// overwrite the previous areamap file, if exists!
	return fopen(filename.c_str(), mode);
}

bool TestAreaStore(){
	// 0. genenate the test data! Test data consists of 15 pointclouds! Each pointcloud consists of 20 points!
	std::vector<pcl::PointCloud<pcl :: PointXYZRGB>::Ptr> pcList;
	std::vector<boost::shared_ptr<Area3DDescMap>> descMapList;
	std::vector<boost::shared_ptr<AreaPathList>> pathLList;
	
	for(int i=0; i<15; i++){
		pcl::PointCloud<pcl::PointXYZRGB>::Ptr pc(new pcl::PointCloud<pcl :: PointXYZRGB>());
		for(int j=0; j<20; j++){
			pcl::PointXYZRGB p; 
			srand((unsigned)j);
			p.x = rand(); p.y = rand(); p.z = rand();
			p.r = ((unsigned)rand())%255; p.g = ((unsigned)rand())%255; p.b = ((unsigned)rand())%255;
			pc->points.push_back(p);
		}
		pcList.push_back(pc);

		boost::shared_ptr<Area3DDescMap> pDescMap(new Area3DDescMap());
		boost::shared_ptr<AreaPathList> pPathLList(new AreaPathList());
		// 30+i nodes in i th area map!
		for(int j=0; j<30+i; j++){
			std::vector<Feature3DDesc> descVector;
			GenTestNodeDesc(descVector);
			pDescMap->insert(Area3DDescMap::value_type(j, descVector));

			// Put node pose into pathlist
			NodePose node={0};
			node.id = j;
			node.pose.x = rand(); node.pose.y = rand(); node.pose.z = rand();
			pPathLList->push_back(node);
		}
		descMapList.push_back(pDescMap);
		pathLList.push_back(pPathLList);
	}

	CAreaStore store;
	// 1. set rootpath
	store.LoadConfig("D:\\areatest\\test");
	// 2. area2file
	for(int n=0; n<pcList.size(); n++){
		// Test area map to file
		AreaStoreHdr hdr = {0};
		hdr.id = (unsigned long)n;
		hdr.size = pcList[n]->points.size();
		store.AreaMap2File(pcList[n], hdr);
	}
	for(int n=0; n<descMapList.size(); n++){
		// Test area descriptor to file		
		Area3DDescStoreHdr hdr={0};
		hdr.id = (unsigned long)n;
		hdr.size = descMapList[n]->size();
		store.Area3DDesc2File(*descMapList[n], hdr);
	}
	for(int n=0; n<pathLList.size(); n++){
		// Test area robot path to file
		AreaPathStoreHdr hdr={0};
		hdr.id = (unsigned long)n;
		hdr.size = pathLList[n]->size();
		store.AreaPath2File(*pathLList[n], hdr);
	}
	// 3. get store header list
	AreaStoreHdrList hdrList;
	store.GetStoreHdrList(hdrList);
	assert(hdrList.size() == pcList.size());
	for(int i=0; i<hdrList.size(); i++){
		if(hdrList[i].size != pcList[hdrList[i].id]->points.size())
			return false;
	}
	// 4. file2area
	for(int i=0; i<hdrList.size(); i++){
		pcl::PointCloud<pcl::PointXYZRGB>::Ptr pc(new pcl::PointCloud<pcl :: PointXYZRGB>());
		store.File2AreaMap(pc, hdrList[i].id);
		assert(pcList[hdrList[i].id]->points.size() == pc->points.size());
		for(int n=0; n<pc->points.size(); n++){
			if(pc->points[n].x== pcList[hdrList[i].id]->points[n].x && 
				pc->points[n].y== pcList[hdrList[i].id]->points[n].y && 
				pc->points[n].z== pcList[hdrList[i].id]->points[n].z && 
				pc->points[n].r== pcList[hdrList[i].id]->points[n].r && 
				pc->points[n].g== pcList[hdrList[i].id]->points[n].g && 
				pc->points[n].b== pcList[hdrList[i].id]->points[n].b)
				continue;
			else
				return false;
		}
	}
	for(int i=0; i<hdrList.size(); i++){
		Area3DDescMap descMap;
		store.File2Area3DDesc(descMap, hdrList[i].id);
		assert(descMapList[hdrList[i].id]->size() == descMap.size());
		Area3DDescMap::iterator it = descMap.begin();
		Area3DDescMap::iterator it2 = descMapList[hdrList[i].id]->begin();
		for(; it != descMap.end(); it++, it2++){
				if(it->first == it2->first && it->second.size() == it2->second.size()){
					for(int i=0; i<it->second.size(); i++)
						if(memcmp(&(it->second[i]),&(it2->second[i]), sizeof(Feature3DDesc)) != 0)
							return false;
				}
		}
	}
	for(int i=0; i<hdrList.size(); i++){
		AreaPathList pathList;
		store.File2AreaPath(pathList, hdrList[i].id);
		assert(pathLList[hdrList[i].id]->size() == pathList.size());
		for(int idx=0; idx<pathList.size();idx++){
			if(memcmp(&(pathList[idx]),&((*pathLList[hdrList[i].id])[idx]), sizeof(NodePose)) != 0)
				return false;
		}
	}
	return true;
}

void GenTestNodeDesc(std::vector<Feature3DDesc>& descVector){
	descVector.clear();
	// N features in this Node
	int N = 30 + rand()%20;
	for(int i=0; i<N; i++)
	{
		Feature3DDesc desc={0};
		desc.xyz.x = rand(); desc.xyz.y = rand(); desc.xyz.z = rand();
		for(int idx=0;idx<64;idx++)
			desc.desc[idx] = rand();
		descVector.push_back(desc);
	}
}